static关键字
1.静态变量或芳芳不属于对象，依赖类
2.静态变量是全局变量，生命周期从被加载后一直到程序结束
3.静态变量只有存一份，在静态方法区中存储
4.静态变量是本类所有对象共享一份
5.建议不用使用对象名取调用静态数据，直接使用类名调用
6.static修饰方法，那么改方法属于类，不属于对象，直接用类名调用
7.静态方法不能访问非静态属性和方法，只能访问静态


static的方法有以下几条限制
1.它们仅能调用其他的static方法
2.它们只能访问static数据
3.它们不能以任何方式引用this或super

什么时候使用static
所有对象共同的属性或方法，那么我们可以定义为静态的


继承
1.继承是发生在多个类之间
2.继承使用的关键字extands
3.java只能单继承，允许多层继承
4.被继承的类叫做父类，继承父类的类叫做子类
5.在父类中的非私有属性和方法可以被子类继承
6.protect(受保护的访问权限修饰符)，修饰的属性可以被子类继承
7.构造方法不能被继承
8.创建对象会调用构造方法，调用构造方法不一定就是创建该类对象
9.实例化子类对象，会先调用父类的构造方法，如果父类中没有默认的构造方法，那么子类必须显示的通过super()来调用父类的带参构造方法，，super也只能在子类构造方法中的第一句
    当父类集中没有午餐构造方法时，子类必须显示的调用父类的带参构造方法，怎么调用：super()

继承的好处
1.提高代码的复用性
2.提高代码的维护性
3.让类与类之间产生关系，是多态的前提

继承的缺点
增强了类与类之间的耦合性

开发原则：高内聚，低耦合


子类的实例化过程
在子类进行实例化的操作的时候，首先会让其父类进行初始化操作，之后子类再自己进行实例化操作
子类实例化过程：
子类实例化时会先调用父类的构造方法
如果父类中没有默认的构造方法，在子类的构造方法中必须显示的调用父类的构造方法
结论
构造方法只是用来初始化类中的字段以及执行一些初始化代码
调用构造发放并不代表会生成对象

方法的重写
在java中，子类可以继承父类中的方法，而不需要重新编写相同的方法，但有时子类并不想原封不动继承父类的方法，而是想做一定的修改，这就需要采用方法的重写，方法重写又称方法覆盖
在子类和父类中，重写方法后，在调用时，以创建的对象类型为准，会调用谁的方法

关于方法重写的一些特性
1.发生在子父类中，防范重写的两个方法返回值，方法名，参数列表必须完全一致(子类重写父类的方法)
2.子类抛出的异常不能超过父类相应方法抛出的异常(子类异常不能大于父类异常)
3.子类方法的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)
4.父类中的方法若使用private/static/final任意修饰符修饰，那么，不能被子类重写

为什么要重写方法，或者方法重写的目的是什么
若子类从父类中继承过来的方法，不能满足子类特有的需求时，子类就需要重写父类中相应的方法，方法的重写也是程序扩展的体现

方法的重载和方法的重写区别
重载：发生在同一个类中，方法名相同，参数列表不同，返回值无关
重写：发生在子父类中，方法名相同，参数列表相同，返回值相同，子类的访问修饰符要大于或等于父类的访问修饰符，子类的异常生命必须小于或等于父类的异常声明，如果方法private,static,final修饰，不能被重写

super关键字
1.使用super调用父类中的属性，可以从父类中获取信息
2.使用super调用父类的方法，可以委托父类对象帮助完成某件事情
3.使用super调用父类中的构造方法(super(实参)形式)，必须在子类构造方法的第一条语句，调用父类中相应的构造方法，若不显示的写出来，默认调用父类的无参构造发放，比如super();

this表示当前对象
使用super来调用父类的属性、方法、构造方法

final关键字
使用final关键字完成一下的操作
1.使用final关键字声明一个常量
    修饰属性或者修饰局部变量(最终变量)，也成为常量
2.使用final关键字声明一个方法
    该方法为最终方法，且还能被子类继承，但是不能被子类重写
3.使用final关键字声明一个类
    该类就转变为最终类，没有子类的类，final修饰的类无法被继承
4.在方法参数中使用final，在该方法内部不能修改参数的值(在内部类中详解)
注意：
1.使用final声明一个属性，就是常量，常量的命名规则建议使用全大写，常量必须在定义式或在构造器中初始化
2.使用final声明的方法，不能被子类重写，只能被继承


--------(Dome3)---------
抽象类
1.很多机油相同特征和行为的对象可以抽象为一个雷，很多具有相同热证和行为的类可以抽象为一个抽象类
2.使用abstract关键字声明的类为抽象类

抽象类规则
1.抽象类可以没有抽象方法，有抽象方法的类必须是抽象类
2.非抽象类继承抽象类必须实现所有抽象方法
3.抽象类可以继承抽象类，可以不识闲父类抽象发放
4.抽象类可以有方法实现和属性
5.抽象类不能被实例化
6.抽象类不能声明为final
7.抽象类可以有构造方法

--------Dome4-----------
接口：
1.格式：
    interface 接口名称{
        全局常量
        抽象方法
    }
2.接口定义的方法没有声明修饰符，默认为public abstract
3.接口的概念：接口是一组行为规范，定义，没有时间(jdk1.8默认方法)
4.使用接口，可以让我们的程序更加利于变化
5.接口是面向对象编程体系中的思想精髓之一
6.面相对象设计法则：基于接口编程
7.接口之间可以多继承，类是只能单继承的
8.实现类可以继承多个接口

接口的使用规范：
1.定义一个接口，使用interface关键字
2.在一个接口中，只能定义常量，抽象发放，jdk1.8后可以定义默认的实现方法
3.接口可以继承多个接口，extend xxx,xxx
4.一个具体类实现接口使用implement关键字
5.一个雷可以实现多个接口
6.抽象类实现接口可以不实现接口的方法
7.在接口中定义的方法没有声明访问修饰符，默认public
8.接口不能有构造方法
9.接口不能被实例化

面对对象设计原则
1.对修改关闭，对扩展开发
2.面相接口编程


多态性
多态是面向对象三大特性之一
什么事多态性？
对象在运行过程中的多种形态

多态性我们大概可以分为两类
1，方法的重载与重写
2.对象的多态性

结论
在编程时针对抽象类型的编写代码，成为面向抽象编程(或面向接口编程)
匪类通常都定义为抽象类，接口

对象的多态性
对象多态性是cognitive继承关系中的多个类而来
向上转移，将子类实例为父类引用
格式：父类 父类对象 = 子类对象 --》自动转换
以基本数据类型操作为：int i = 'a';
因为char的容量比int小，所以可以自动完成

向下转型：将父类实例转为子类实例
格式：子类 子类对象 = (子类)父类实例; 强制转换
以基本数据类型操作为例：char c = (char)97;
因为整形是4个字节比char2个字节要打，所以需要强制完成

多态性小结
1.方法的重载与重写就是方法的多态性表现
2.多个子类就是父类中的多种形态
3.父类引用可以指向子类对象，自动转换
4.子类对象指向父类引用需要强制转换(注意：类型不对会报异常)
6.再实际开发中尽量使用父类引用(更利于扩展)


instanceof关键字
用于检查对象是否为指定的类型，通常在把父类引用强制转换为子类引用时要使用，以避免发生类型转换异常(chlassCastException)

语法：
对象 instanceof 类型  --> 返回boolean类型值

示例
if (homeChicken instanceof Chicken){
    //.....
}

该语句一般用于哦安短一个对象是否为某个类的实力，是返回true，否返回false

父类的设计法则
通过instanceof关键字，我们可以和方便的检查对象的类型但如果一个父类的子类过多，这样的判断还是显得很繁琐，那么如何去设计一个父类呢？
1.父类通常情况下都涉及为抽象类或接口，其中优先考虑接口，如果接口不能满足才考虑抽象类
2.一个具体的类尽可能不去继承另一个具体类，这样的好处是无需检查对象是否为父类的对象


抽象类应用-模板发放模式
定义一个操作中的算法和股价，而将一些可变部分的实现延迟到子类中，模板发放模式使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定的步骤
