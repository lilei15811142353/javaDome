static关键字
1.静态变量或芳芳不属于对象，依赖类
2.静态变量是全局变量，生命周期从被加载后一直到程序结束
3.静态变量只有存一份，在静态方法区中存储
4.静态变量是本类所有对象共享一份
5.建议不用使用对象名取调用静态数据，直接使用类名调用
6.static修饰方法，那么改方法属于类，不属于对象，直接用类名调用
7.静态方法不能访问非静态属性和方法，只能访问静态


static的方法有以下几条限制
1.它们仅能调用其他的static方法
2.它们只能访问static数据
3.它们不能以任何方式引用this或super

什么时候使用static
所有对象共同的属性或方法，那么我们可以定义为静态的


继承
1.继承是发生在多个类之间
2.继承使用的关键字extands
3.java只能单继承，允许多层继承
4.被继承的类叫做父类，继承父类的类叫做子类
5.在父类中的非私有属性和方法可以被子类继承
6.protect(受保护的访问权限修饰符)，修饰的属性可以被子类继承
7.构造方法不能被继承
8.创建对象会调用构造方法，调用构造方法不一定就是创建该类对象
9.实例化子类对象，会先调用父类的构造方法，如果父类中没有默认的构造方法，那么子类必须显示的通过super()来调用父类的带参构造方法，，super也只能在子类构造方法中的第一句
    当父类集中没有午餐构造方法时，子类必须显示的调用父类的带参构造方法，怎么调用：super()

继承的好处
1.提高代码的复用性
2.提高代码的维护性
3.让类与类之间产生关系，是多态的前提

继承的缺点
增强了类与类之间的耦合性

开发原则：高内聚，低耦合


子类的实例化过程
在子类进行实例化的操作的时候，首先会让其父类进行初始化操作，之后子类再自己进行实例化操作
子类实例化过程：
子类实例化时会先调用父类的构造方法
如果父类中没有默认的构造方法，在子类的构造方法中必须显示的调用父类的构造方法
结论
构造方法只是用来初始化类中的字段以及执行一些初始化代码
调用构造发放并不代表会生成对象

方法的重写
在java中，子类可以继承父类中的方法，而不需要重新编写相同的方法，但有时子类并不想原封不动继承父类的方法，而是想做一定的修改，这就需要采用方法的重写，方法重写又称方法覆盖
在子类和父类中，重写方法后，在调用时，以创建的对象类型为准，会调用谁的方法

关于方法重写的一些特性
1.发生在子父类中，防范重写的两个方法返回值，方法名，参数列表必须完全一致(子类重写父类的方法)
2.子类抛出的异常不能超过父类相应方法抛出的异常(子类异常不能大于父类异常)
3.子类方法的访问级别不能低于父类相应方法的访问级别(子类访问级别不能低于父类访问级别)
4.父类中的方法若使用private/static/final任意修饰符修饰，那么，不能被子类重写

为什么要重写方法，或者方法重写的目的是什么
若子类从父类中继承过来的方法，不能满足子类特有的需求时，子类就需要重写父类中相应的方法，方法的重写也是程序扩展的体现

方法的重载和方法的重写区别
重载：发生在同一个类中，方法名相同，参数列表不同，返回值无关
重写：发生在子父类中，方法名相同，参数列表相同，返回值相同，子类的访问修饰符要大于或等于父类的访问修饰符，子类的异常生命必须小于或等于父类的异常声明，如果方法private,static,final修饰，不能被重写

super关键字
1.使用super调用父类中的属性，可以从父类中获取信息
2.使用super调用父类的方法，可以委托父类对象帮助完成某件事情
3.使用super调用父类中的构造方法(super(实参)形式)，必须在子类构造方法的第一条语句，调用父类中相应的构造方法，若不显示的写出来，默认调用父类的无参构造发放，比如super();

this表示当前对象
使用super来调用父类的属性、方法、构造方法

final关键字
使用final关键字完成一下的操作
1.使用final关键字声明一个常量
    修饰属性或者修饰局部变量(最终变量)，也成为常量
2.使用final关键字声明一个方法
    该方法为最终方法，且还能被子类继承，但是不能被子类重写
3.使用final关键字声明一个类
    该类就转变为最终类，没有子类的类，final修饰的类无法被继承
4.在方法参数中使用final，在该方法内部不能修改参数的值(在内部类中详解)
注意：
1.使用final声明一个属性，就是常量，常量的命名规则建议使用全大写，常量必须在定义式或在构造器中初始化
2.使用final声明的方法，不能被子类重写，只能被继承


--------(Dome3)---------
抽象类
1.很多机油相同特征和行为的对象可以抽象为一个雷，很多具有相同热证和行为的类可以抽象为一个抽象类
2.使用abstract关键字声明的类为抽象类

抽象类规则
1.抽象类可以没有抽象方法，有抽象方法的类必须是抽象类
2.非抽象类继承抽象类必须实现所有抽象方法
3.抽象类可以继承抽象类，可以不识闲父类抽象发放
4.抽象类可以有方法实现和属性
5.抽象类不能被实例化
6.抽象类不能声明为final
7.抽象类可以有构造方法

--------Dome4-----------
接口：
1.格式：
    interface 接口名称{
        全局常量
        抽象方法
    }
2.接口定义的方法没有声明修饰符，默认为public abstract
3.接口的概念：接口是一组行为规范，定义，没有时间(jdk1.8默认方法)
4.使用接口，可以让我们的程序更加利于变化
5.接口是面向对象编程体系中的思想精髓之一
6.面相对象设计法则：基于接口编程
7.接口之间可以多继承，类是只能单继承的
8.实现类可以继承多个接口

接口的使用规范：
1.定义一个接口，使用interface关键字
2.在一个接口中，只能定义常量，抽象发放，jdk1.8后可以定义默认的实现方法
3.接口可以继承多个接口，extend xxx,xxx
4.一个具体类实现接口使用implement关键字
5.一个雷可以实现多个接口
6.抽象类实现接口可以不实现接口的方法
7.在接口中定义的方法没有声明访问修饰符，默认public
8.接口不能有构造方法
9.接口不能被实例化

面对对象设计原则
1.对修改关闭，对扩展开发
2.面相接口编程


多态性
多态是面向对象三大特性之一
什么事多态性？
对象在运行过程中的多种形态

多态性我们大概可以分为两类
1，方法的重载与重写
2.对象的多态性

结论
在编程时针对抽象类型的编写代码，成为面向抽象编程(或面向接口编程)
匪类通常都定义为抽象类，接口

对象的多态性
对象多态性是cognitive继承关系中的多个类而来
向上转移，将子类实例为父类引用
格式：父类 父类对象 = 子类对象 --》自动转换
以基本数据类型操作为：int i = 'a';
因为char的容量比int小，所以可以自动完成

向下转型：将父类实例转为子类实例
格式：子类 子类对象 = (子类)父类实例; 强制转换
以基本数据类型操作为例：char c = (char)97;
因为整形是4个字节比char2个字节要打，所以需要强制完成

多态性小结
1.方法的重载与重写就是方法的多态性表现
2.多个子类就是父类中的多种形态
3.父类引用可以指向子类对象，自动转换
4.子类对象指向父类引用需要强制转换(注意：类型不对会报异常)
6.再实际开发中尽量使用父类引用(更利于扩展)


instanceof关键字
用于检查对象是否为指定的类型，通常在把父类引用强制转换为子类引用时要使用，以避免发生类型转换异常(chlassCastException)

语法：
对象 instanceof 类型  --> 返回boolean类型值

示例
if (homeChicken instanceof Chicken){
    //.....
}

该语句一般用于哦安短一个对象是否为某个类的实力，是返回true，否返回false

父类的设计法则
通过instanceof关键字，我们可以和方便的检查对象的类型但如果一个父类的子类过多，这样的判断还是显得很繁琐，那么如何去设计一个父类呢？
1.父类通常情况下都涉及为抽象类或接口，其中优先考虑接口，如果接口不能满足才考虑抽象类
2.一个具体的类尽可能不去继承另一个具体类，这样的好处是无需检查对象是否为父类的对象


抽象类应用-模板发放模式
定义一个操作中的算法和股价，而将一些可变部分的实现延迟到子类中，模板发放模式使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定的步骤

接口应用--策略模式
定义了一系列算法，将每一种算法封装起来并可以相互替换使用，策略模式让算法独立于使用它的客户应用而独立变化
设计原则
1.面相接口编程(面相抽象编程)
2.封装变化
3.多用组合，少用继承


Object类
每个类都使用Object作为超类。所有对象(包括数组)的都实现这个类的方法
所有类都是Object类的子类

public String toString()方法
返回该对象的字符串表示
通常，toString 方法会返回一个 以文本方式表示 此对象的字符串，结果应是一个简明且易于读懂的信息表达式。建议所有子类都重写此方法

public boolean equals(Object obj)
只是其他某个对象是否与此对象 相等 。equals方法再非空对象引用上实现相等关系
自反性
对称性
传递性
一致性

protceted void finalize()throws Throwable
当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。子类冲洗呢finalize方法，以配置系统资源或执行其他清楚

public final Class<?>getClass()
返回此Object的运行时类

接口应用-简单工厂设计模式
简单工厂模式是由一个工厂对象决定创建处哪一种产品类的实力。简单工厂模式是工厂模式家族中最简单实用的模式


内部类：
1.成员内部类
内部类就是在一个类的内部定义的类
成员内部类格式如下
class Outer{
    class Inner{}
}
编译上述代码会产生两个文件
Outer.class和Outer$Inner.class

2.方法内部类
内部类可以作为一个类的成员外，还可以把类放在方法内定义
    注意：
        1.方法内部类只能在定义该内部类的方法内实例化，不可以在此方法外对其实例化
        2.方法内部类对象不能使用该内部类所在方法的非final局部变量
格式如下
class Outer(){
    public void doSomething(){
        class Inner(){
            public void seeOuter(){}
        }
    }
}

3.静态内部类
在一个类内部定义一个静态内部类
静态的含义是该内部类可以像其他静态成员一样，没有外部类对象时，也能访问它。静态嵌套类仅能访问外部类的静态成员和方法

class Outer{
    static class Inner{}
}

class Test{
    public static void main(String[] args){
        Outer.Inner n = new Outer.Inner();
    }
}

4.匿名内部类就是没有名字的内部类
 匿名内部类的三种情况
    1).继承式的匿名内部类
    2).接口式的几名内部类
    3).参数式的匿名内部类

 在使用匿名累不累时，要注意一下几个原则
    1、不能有构造方法，只能有一个实例
    2、不能定义任何静态成员、静态方法
    3、不能是public pritected private static
    4、一定是在new的后面，用其隐含实现一个接口或实现一个类
    5、匿名内部类为局部的。所以局部内部类的所有限制都对其生效


问题：局部内部类访问局部变量必须用final修饰，为什么？(jdk1.8取消了这个特性)
    当调用这个方法时，局部变量如果没有用final修饰，他的生命周期和方法的生命周期是一样的，当方法被调用时会入栈，方法结束后会弹栈，这个局部变量也会消失，
    那么如果局部内部类对象还没有马上消失想用这个局部变量，显然已无法使用了，如果用final修饰会在类加载的时候进入常量池，即使方法弹栈，常量池的常量还在，也就可以继续使用了


内部类作用
    每一个内部类都能独立的继承自一个(接口的)实现，素有无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。
    从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了多重继承

 一来外部类对象的：成员内部类，方法内部类，匿名内部类
 静态内部类不依赖外部类的对象。所以，我么在项目中优先考虑选择静态内部类(内存泄漏)


数据结构之链表
在链表数据结构中，我们需要使用到递归算法
递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简介而且易于理解
链表：是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一节点里面存到时下一个节点的指针(pointer)

链表和数组都属于线性数据结果
数组适合查找、遍历，是固定长度
链表适合插入、删除，不宜过长，否则会导致遍历性能下降


基本数据类型包装类
转型操作
在包装类中，可以将一个字符串变为指定的基本数据类型，一般在输入数据时会使用比较多
在Integer类中将String变为int型数据：public static int parselnt(String s)
在Float类中将String变为float型数据：pubulc static float parseFloat(String s)
注意：转型操作时，字符串必须由数字组成，否则会报错

享元模式：它使用共享对象，用来尽可能减少内存使用量以及分享咨询给尽可能多的相似对象，它适合用于大量对象只是重复因而导致无法令人接受的使用大量内存。通常对象中的部分状态是可以分享。
         常见做法是把它们放在外部数据结构，当需要使用时再将他们传递给享元。